{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Bomb/","text":"Bomb.gd Ce script permet de g\u00e9rer les bombes : leur apparence, leur temps d\u2019explosion et les sprites de l\u2019explosion. Extends: [RigidBody2D] Variables Gestion de la relation joueur-bombes Collision pour savoir si le joueur est sorti de la bombe lorsqu\u2019il la pose : || onready var cShape R\u00e9f\u00e9rence au GameManager, pour le pr\u00e9venir quand le joueur perd (en cas de collision joueur-explosion): || onready var gameManager Importation des sc\u00e8nes affichant les sprites de l\u2019explosion Animation du centre de l\u2019explosion : || var ExC Animation des bras centre de l\u2019explosion : || var ExM Animation du centre de l\u2019explosion : || var ExMC Animation de la fin des bras de l\u2019explosion : || var ExF Donn\u00e9es sur les capacit\u00e9s et l\u2019\u00e9tat de la bombe Indique si la bombe a d\u00e9j\u00e0 explos\u00e9 : || onready var exploded Port\u00e9e de la bombe, initialis\u00e9e \u00e0 3 : || var bomb_range Tableau des objets pr\u00e9sents dans la zone d\u2019explosion : || var in_bomb_range Fonctions Sc\u00e8nes Fonction appel\u00e9e quand le node entre pour la premi\u00e8re fois sur la sc\u00e8ne, permet \u00e0 la bombe une absence de rotation : || func ready() Mise \u00e0 jour des variables Fonction appel\u00e9e lorsque la bombe a \u00e9t\u00e9 pos\u00e9e, sert \u00e0 initialiser des variables n\u00e9cessaires par la suite: || func posed() Animation de l\u2019explosion Fonction servant \u00e0 faire appara\u00eetre des textures d\u2019explosion au moment de l\u2019explosion de la bombe, en fonction de la port\u00e9e de la bombe. Il faut aussi g\u00e9rer le fait que les textures ne sont pas les m\u00eames au centre de l\u2019explosion que sur les cot\u00e9s ou au bout de la port\u00e9e de l\u2019explosion : || func explodeTextures() Fonction d\u2019explosion de la bombe, lanc\u00e9e au terme du timer qui lui est associ\u00e9, joue le son d\u2019explosion, cr\u00e9e les textures d\u2019explosion et d\u00e9truit ce qui est \u00e0 port\u00e9e d\u2019explosion. Pour cela, on regarde ce qu\u2019il y dans le tableau des objets pr\u00e9sents dans la zone d\u2019explosion et on appelle la fonction \u201cbombed\u201d de chacun de ces objets si ils ont une telle m\u00e9thode (= si ils peuvent \u00eatre d\u00e9truits) : || func MACRONEXPLOSION() Gestion des collisions (effets de l\u2019explosion) Change les tailles de CollisionShape2D associ\u00e9es \u00e0 la d\u00e9tection d\u2019objets \u00e9tant dans la zone d\u2019explosion de la bombe, en fonction de sa port\u00e9e r : rayon d\u2019explosion en cases : || func resizeShape(r) Permet de ne pas pouvoir collisionner avec la bombe si elle vient d\u2019\u00eatre pos\u00e9e. On attend alors que le joueur ne soit plus sur la bombe pour la rendre collisionnable \u00e0 nouveau : || func on_Area2D_body_exited(body) Lorsqu\u2019un objet entre dans la zone d\u2019explosion de la bombe, on l\u2019ajoute \u00e0 un tableau : || func on_AreaExplo_body_entered(body) Lorsqu\u2019un objet sort de la zone d\u2019explosion de la bombe on le retire du tableau : || func on_AreaExplo_body_exited(body)","title":"Bomb"},{"location":"Bomb/#bombgd","text":"Ce script permet de g\u00e9rer les bombes : leur apparence, leur temps d\u2019explosion et les sprites de l\u2019explosion. Extends: [RigidBody2D]","title":"Bomb.gd"},{"location":"Bomb/#variables","text":"","title":"Variables"},{"location":"Bomb/#gestion-de-la-relation-joueur-bombes","text":"Collision pour savoir si le joueur est sorti de la bombe lorsqu\u2019il la pose : || onready var cShape R\u00e9f\u00e9rence au GameManager, pour le pr\u00e9venir quand le joueur perd (en cas de collision joueur-explosion): || onready var gameManager","title":"Gestion de la relation joueur-bombes"},{"location":"Bomb/#importation-des-scenes-affichant-les-sprites-de-lexplosion","text":"Animation du centre de l\u2019explosion : || var ExC Animation des bras centre de l\u2019explosion : || var ExM Animation du centre de l\u2019explosion : || var ExMC Animation de la fin des bras de l\u2019explosion : || var ExF","title":"Importation des sc\u00e8nes affichant les sprites de l'explosion"},{"location":"Bomb/#donnees-sur-les-capacites-et-letat-de-la-bombe","text":"Indique si la bombe a d\u00e9j\u00e0 explos\u00e9 : || onready var exploded Port\u00e9e de la bombe, initialis\u00e9e \u00e0 3 : || var bomb_range Tableau des objets pr\u00e9sents dans la zone d\u2019explosion : || var in_bomb_range","title":"Donn\u00e9es sur les capacit\u00e9s et l'\u00e9tat de la bombe"},{"location":"Bomb/#fonctions","text":"","title":"Fonctions"},{"location":"Bomb/#scenes","text":"Fonction appel\u00e9e quand le node entre pour la premi\u00e8re fois sur la sc\u00e8ne, permet \u00e0 la bombe une absence de rotation : || func ready()","title":"Sc\u00e8nes"},{"location":"Bomb/#mise-a-jour-des-variables","text":"Fonction appel\u00e9e lorsque la bombe a \u00e9t\u00e9 pos\u00e9e, sert \u00e0 initialiser des variables n\u00e9cessaires par la suite: || func posed()","title":"Mise \u00e0 jour des variables"},{"location":"Bomb/#animation-de-lexplosion","text":"Fonction servant \u00e0 faire appara\u00eetre des textures d\u2019explosion au moment de l\u2019explosion de la bombe, en fonction de la port\u00e9e de la bombe. Il faut aussi g\u00e9rer le fait que les textures ne sont pas les m\u00eames au centre de l\u2019explosion que sur les cot\u00e9s ou au bout de la port\u00e9e de l\u2019explosion : || func explodeTextures() Fonction d\u2019explosion de la bombe, lanc\u00e9e au terme du timer qui lui est associ\u00e9, joue le son d\u2019explosion, cr\u00e9e les textures d\u2019explosion et d\u00e9truit ce qui est \u00e0 port\u00e9e d\u2019explosion. Pour cela, on regarde ce qu\u2019il y dans le tableau des objets pr\u00e9sents dans la zone d\u2019explosion et on appelle la fonction \u201cbombed\u201d de chacun de ces objets si ils ont une telle m\u00e9thode (= si ils peuvent \u00eatre d\u00e9truits) : || func MACRONEXPLOSION()","title":"Animation de l'explosion"},{"location":"Bomb/#gestion-des-collisions-effets-de-lexplosion","text":"Change les tailles de CollisionShape2D associ\u00e9es \u00e0 la d\u00e9tection d\u2019objets \u00e9tant dans la zone d\u2019explosion de la bombe, en fonction de sa port\u00e9e r : rayon d\u2019explosion en cases : || func resizeShape(r) Permet de ne pas pouvoir collisionner avec la bombe si elle vient d\u2019\u00eatre pos\u00e9e. On attend alors que le joueur ne soit plus sur la bombe pour la rendre collisionnable \u00e0 nouveau : || func on_Area2D_body_exited(body) Lorsqu\u2019un objet entre dans la zone d\u2019explosion de la bombe, on l\u2019ajoute \u00e0 un tableau : || func on_AreaExplo_body_entered(body) Lorsqu\u2019un objet sort de la zone d\u2019explosion de la bombe on le retire du tableau : || func on_AreaExplo_body_exited(body)","title":"Gestion des collisions (effets de l'explosion)"},{"location":"Enemy/","text":"Enemy.gd Ce script permet de g\u00e9rer les mouvements et les interactions des ennemis. Extends: [KinematicBody2D] Variables D\u00e9placement de l\u2019ennemi Vitesse de l\u2019ennemi, initialis\u00e9e \u00e0 100 : || var speed Tableau de vector2 qui permet de stocker le chemin que doit suivre l\u2019ennemi : || var path Position actuelle dans le path, initialis\u00e9e \u00e0 0 : || var indice Variable permettant de savoir dans quel sens se d\u00e9place l\u2019ennemi, initialis\u00e9e \u00e0 1 : || var direction Variable permettant de stocker la TileMap du maze pour savoir comment se d\u00e9placer : || var maze Interactions avec le joueur Variable permettant de stocker l\u2019objet qui vient d\u2019entrer en collision avec l\u2019ennemi : || var pre Variable permettant de savoir si l\u2019ennemi suit un joueur, initialis\u00e9e \u00e0 false : || var isChasing Variable stockant le joueur qui est suivi : || var chasingPlayer Types d\u2019ennemis Variable permettant de g\u00e9rer le type de l\u2019ennemi (passif, actif ou aggressif) : || var type Variable stockant un nombre g\u00e9n\u00e9r\u00e9 al\u00e9atoirement : || onready var rng Fonctions Sc\u00e8ne Fonction lanc\u00e9e \u00e0 l\u2019instanciation de l\u2019ennemi. Sert \u00e0 seeder le g\u00e9n\u00e9rateur de nombres al\u00e9atoires et \u00e0 donner un nouveau chemin al\u00e9atoire \u00e0 l\u2019ennemi. On en profite pour cr\u00e9er un timer qui donnera un nouveau chemin toutes les 15 secondes \u00e0 l\u2019ennemi si il est actif : || func ready() Fonction lanc\u00e9e \u00e0 chaque frame permettant de d\u00e9placer l\u2019ennemi en fonction du chemin g\u00e9n\u00e9r\u00e9. Permet aussi de g\u00e9rer les collisions lors des d\u00e9placements: || func process(delta) Misc Remplace les valeurs \u00e9tant NaN d\u2019un vecteur par des 0 : || func deNan(n) Type Assigne al\u00e9atoirement un type d\u2019ennemi \u00e0 l\u2019ennemi en cours parmi passif, actif et aggressif et lui donne une texture et une animation en cons\u00e9quence : || func getType() D\u00e9placements Renvoie un tableau de coordonn\u00e9es constituant un chemin bouclant sur lui-m\u00eame et commen\u00e7ant \u00e0 la position actuelle de l\u2019ennemi. La longueur d\u00e9pend d\u2019un param\u00e8tre al\u00e9atoire. On commence par faire la moiti\u00e9 du chemin en prenant al\u00e9atoirement une nouvelle case adjacente \u00e0 chaque fois. Puis le retour se fait gr\u00e2ce \u00e0 un algorithme A , l\u2019ennemi fera donc demi tour pour revenir \u00e0 son point de d\u00e9part, en essayant le plus possible d\u2019\u00e9viter les cases par lesquelles il est d\u00e9ja pass\u00e9 afin d\u2019\u00e9viter qu\u2019il revienne simplement sur ses pas. : || func getNewPassivePath() * Gestion de la mort des ennemis par les bombes M\u00e9thode qui est appell\u00e9e par Bomb.gd si l\u2019ennemi est touch\u00e9 par l\u2019explosion d\u2019une bombe. Il est alors d\u00e9truit. : || func bombed() Ennemis Aggressifs Renvoie un tableau de positions \u00e9tablissant un chemin entre la case courante de l\u2019ennemi et la position du joueur pass\u00e9e en param\u00e8tre : || func getPathToPlayer() Si quelque chose entre dans le rayon de vision de l\u2019ennemi. Sert \u00e0 faire que les ennemis aggressifs chassent les joueurs si ils sont assez pr\u00e8s : || func on_Area2D2_body_entered(body) Si un objet quitte le rayon de vision de l\u2019ennemi. Sert \u00e0 rendre son comportement normal \u00e0 un ennemi : || func on_Area2D2_body_exited(body)","title":"Enemy"},{"location":"Enemy/#enemygd","text":"Ce script permet de g\u00e9rer les mouvements et les interactions des ennemis. Extends: [KinematicBody2D]","title":"Enemy.gd"},{"location":"Enemy/#variables","text":"","title":"Variables"},{"location":"Enemy/#deplacement-de-lennemi","text":"Vitesse de l\u2019ennemi, initialis\u00e9e \u00e0 100 : || var speed Tableau de vector2 qui permet de stocker le chemin que doit suivre l\u2019ennemi : || var path Position actuelle dans le path, initialis\u00e9e \u00e0 0 : || var indice Variable permettant de savoir dans quel sens se d\u00e9place l\u2019ennemi, initialis\u00e9e \u00e0 1 : || var direction Variable permettant de stocker la TileMap du maze pour savoir comment se d\u00e9placer : || var maze","title":"D\u00e9placement de l'ennemi"},{"location":"Enemy/#interactions-avec-le-joueur","text":"Variable permettant de stocker l\u2019objet qui vient d\u2019entrer en collision avec l\u2019ennemi : || var pre Variable permettant de savoir si l\u2019ennemi suit un joueur, initialis\u00e9e \u00e0 false : || var isChasing Variable stockant le joueur qui est suivi : || var chasingPlayer","title":"Interactions avec le joueur"},{"location":"Enemy/#types-dennemis","text":"Variable permettant de g\u00e9rer le type de l\u2019ennemi (passif, actif ou aggressif) : || var type Variable stockant un nombre g\u00e9n\u00e9r\u00e9 al\u00e9atoirement : || onready var rng","title":"Types d'ennemis"},{"location":"Enemy/#fonctions","text":"","title":"Fonctions"},{"location":"Enemy/#scene","text":"Fonction lanc\u00e9e \u00e0 l\u2019instanciation de l\u2019ennemi. Sert \u00e0 seeder le g\u00e9n\u00e9rateur de nombres al\u00e9atoires et \u00e0 donner un nouveau chemin al\u00e9atoire \u00e0 l\u2019ennemi. On en profite pour cr\u00e9er un timer qui donnera un nouveau chemin toutes les 15 secondes \u00e0 l\u2019ennemi si il est actif : || func ready() Fonction lanc\u00e9e \u00e0 chaque frame permettant de d\u00e9placer l\u2019ennemi en fonction du chemin g\u00e9n\u00e9r\u00e9. Permet aussi de g\u00e9rer les collisions lors des d\u00e9placements: || func process(delta)","title":"Sc\u00e8ne"},{"location":"Enemy/#misc","text":"Remplace les valeurs \u00e9tant NaN d\u2019un vecteur par des 0 : || func deNan(n)","title":"Misc"},{"location":"Enemy/#type","text":"Assigne al\u00e9atoirement un type d\u2019ennemi \u00e0 l\u2019ennemi en cours parmi passif, actif et aggressif et lui donne une texture et une animation en cons\u00e9quence : || func getType()","title":"Type"},{"location":"Enemy/#deplacements","text":"Renvoie un tableau de coordonn\u00e9es constituant un chemin bouclant sur lui-m\u00eame et commen\u00e7ant \u00e0 la position actuelle de l\u2019ennemi. La longueur d\u00e9pend d\u2019un param\u00e8tre al\u00e9atoire. On commence par faire la moiti\u00e9 du chemin en prenant al\u00e9atoirement une nouvelle case adjacente \u00e0 chaque fois. Puis le retour se fait gr\u00e2ce \u00e0 un algorithme A , l\u2019ennemi fera donc demi tour pour revenir \u00e0 son point de d\u00e9part, en essayant le plus possible d\u2019\u00e9viter les cases par lesquelles il est d\u00e9ja pass\u00e9 afin d\u2019\u00e9viter qu\u2019il revienne simplement sur ses pas. : || func getNewPassivePath() *","title":"D\u00e9placements"},{"location":"Enemy/#gestion-de-la-mort-des-ennemis-par-les-bombes","text":"M\u00e9thode qui est appell\u00e9e par Bomb.gd si l\u2019ennemi est touch\u00e9 par l\u2019explosion d\u2019une bombe. Il est alors d\u00e9truit. : || func bombed()","title":"Gestion de la mort des ennemis par les bombes"},{"location":"Enemy/#ennemis-aggressifs","text":"Renvoie un tableau de positions \u00e9tablissant un chemin entre la case courante de l\u2019ennemi et la position du joueur pass\u00e9e en param\u00e8tre : || func getPathToPlayer() Si quelque chose entre dans le rayon de vision de l\u2019ennemi. Sert \u00e0 faire que les ennemis aggressifs chassent les joueurs si ils sont assez pr\u00e8s : || func on_Area2D2_body_entered(body) Si un objet quitte le rayon de vision de l\u2019ennemi. Sert \u00e0 rendre son comportement normal \u00e0 un ennemi : || func on_Area2D2_body_exited(body)","title":"Ennemis Aggressifs"},{"location":"GameManager/","text":"GameManager.gd Ce script permet de g\u00e9rer les instances du jeu : la maze, le(s) joueur(s), les bonus, les bombes\u2026 >Il permet de lancer les parties et les diff\u00e9rents \u00e9crans de transitions entre les parties. C\u2019est le coeur du jeu. Extends: [Node] Variables D\u00e9claration des diff\u00e9rentes sc\u00e8nes en les chargeant depuis un path Chargement de la sc\u00e8ne d\u2019accueil : || var accueil_scene Chargement de la sc\u00e8ne de fin de partie/niveau : || var endofgame_scene Chargement de la sc\u00e8ne de maze : || var maze_scene D\u00e9claration des diff\u00e9rentes instanciations li\u00e9es aux sc\u00e8nes Instance de l\u2019\u00e9cran d\u2019accueil : || var accueil_instance Instance de fin de partie/niveau : || var endofgame_instance Instance de la maze : || var maze_instance D\u00e9claration des variables utiles \u00e0 la maze Difficult\u00e9 de la maze pour le mode solo initialis\u00e9e \u00e0 0.1 : || var maze_difficulty Nombre de joueur pouvant int\u00e9ragir initialis\u00e9 \u00e0 1 : || var nb_player variable du score du joueur en mode solo initialis\u00e9 \u00e0 0 : || var player_score Fonctions Sc\u00e8nes Lance une instance du splash screen (\u00e9cran d\u2019accueil) en fils du GameManager. Affiche cette instance : || func ready() Getters Retourne la valeur de la variable maze_difficulty : || func get_difficulty() Retourne la valeur de la variable nb_player : || func get_nbPlayer() Setters Met \u00e0 jour la valeur de la variable nb_player : || func set_nb_player(nbPlayer) Fonction permettant d\u2019incr\u00e9menter le score en fonction des actions du joueur (Il marque 10 points pour un mur cass\u00e9, 30 points pour un bonus attrap\u00e9, 60 points pour un ennemi tu\u00e9 et 100 points pour la victoire sur un niveau) : || func change_score(action) Constructeurs Permet d\u2019instancier et d\u2019afficher la maze : || func new_maze() Permet d\u2019instancier et d\u2019afficher l\u2019\u00e9cran d\u2019accueil (apr\u00e8s une fin de partie) : || func retour_accueil() Permet d\u2019instancier et d\u2019afficher l\u2019\u00e9cran de d\u00e9faite en solo : || func defeat() Permet d\u2019instancier et d\u2019afficher l\u2019\u00e9cran de victoire en solo : || func victory() Permet d\u2019instancier et d\u2019afficher l\u2019\u00e9cran de fin de partie multi (elle prend en param\u00e8tre l\u2019id du joueur gagnant et affiche le nom de la couleur qui lui correspond comme \u00e9tant le gagnant. Si aucun des joueurs ne gagne, le param\u00e8tre pass\u00e9 en entr\u00e9e vaut -1) : || func multi(id_joueur) Killers Les killers permettent de lib\u00e9rer les instanciations Permet de lib\u00e9rer l\u2019instance de l\u2019\u00e9cran d\u2019acceuil : || func kill_accueil() Permet de lib\u00e9rer l\u2019instance de maze : || func kill_maze() Permet de lib\u00e9rer l\u2019instance de l\u2019\u00e9cran de fin de partie : || func kill_endOfGame() G\u00e8re des instances de : EndOfGame , MainMenu et Maze","title":"GameManager"},{"location":"GameManager/#gamemanagergd","text":"Ce script permet de g\u00e9rer les instances du jeu : la maze, le(s) joueur(s), les bonus, les bombes\u2026 >Il permet de lancer les parties et les diff\u00e9rents \u00e9crans de transitions entre les parties. C\u2019est le coeur du jeu. Extends: [Node]","title":"GameManager.gd"},{"location":"GameManager/#variables","text":"","title":"Variables"},{"location":"GameManager/#declaration-des-differentes-scenes-en-les-chargeant-depuis-un-path","text":"Chargement de la sc\u00e8ne d\u2019accueil : || var accueil_scene Chargement de la sc\u00e8ne de fin de partie/niveau : || var endofgame_scene Chargement de la sc\u00e8ne de maze : || var maze_scene","title":"D\u00e9claration des diff\u00e9rentes sc\u00e8nes en les chargeant depuis un path"},{"location":"GameManager/#declaration-des-differentes-instanciations-liees-aux-scenes","text":"Instance de l\u2019\u00e9cran d\u2019accueil : || var accueil_instance Instance de fin de partie/niveau : || var endofgame_instance Instance de la maze : || var maze_instance","title":"D\u00e9claration des diff\u00e9rentes instanciations li\u00e9es aux sc\u00e8nes"},{"location":"GameManager/#declaration-des-variables-utiles-a-la-maze","text":"Difficult\u00e9 de la maze pour le mode solo initialis\u00e9e \u00e0 0.1 : || var maze_difficulty Nombre de joueur pouvant int\u00e9ragir initialis\u00e9 \u00e0 1 : || var nb_player variable du score du joueur en mode solo initialis\u00e9 \u00e0 0 : || var player_score","title":"D\u00e9claration des variables utiles \u00e0 la maze"},{"location":"GameManager/#fonctions","text":"","title":"Fonctions"},{"location":"GameManager/#scenes","text":"Lance une instance du splash screen (\u00e9cran d\u2019accueil) en fils du GameManager. Affiche cette instance : || func ready()","title":"Sc\u00e8nes"},{"location":"GameManager/#getters","text":"Retourne la valeur de la variable maze_difficulty : || func get_difficulty() Retourne la valeur de la variable nb_player : || func get_nbPlayer()","title":"Getters"},{"location":"GameManager/#setters","text":"Met \u00e0 jour la valeur de la variable nb_player : || func set_nb_player(nbPlayer) Fonction permettant d\u2019incr\u00e9menter le score en fonction des actions du joueur (Il marque 10 points pour un mur cass\u00e9, 30 points pour un bonus attrap\u00e9, 60 points pour un ennemi tu\u00e9 et 100 points pour la victoire sur un niveau) : || func change_score(action)","title":"Setters"},{"location":"GameManager/#constructeurs","text":"Permet d\u2019instancier et d\u2019afficher la maze : || func new_maze() Permet d\u2019instancier et d\u2019afficher l\u2019\u00e9cran d\u2019accueil (apr\u00e8s une fin de partie) : || func retour_accueil() Permet d\u2019instancier et d\u2019afficher l\u2019\u00e9cran de d\u00e9faite en solo : || func defeat() Permet d\u2019instancier et d\u2019afficher l\u2019\u00e9cran de victoire en solo : || func victory() Permet d\u2019instancier et d\u2019afficher l\u2019\u00e9cran de fin de partie multi (elle prend en param\u00e8tre l\u2019id du joueur gagnant et affiche le nom de la couleur qui lui correspond comme \u00e9tant le gagnant. Si aucun des joueurs ne gagne, le param\u00e8tre pass\u00e9 en entr\u00e9e vaut -1) : || func multi(id_joueur)","title":"Constructeurs"},{"location":"GameManager/#killers","text":"","title":"Killers"},{"location":"GameManager/#les-killers-permettent-de-liberer-les-instanciations","text":"Permet de lib\u00e9rer l\u2019instance de l\u2019\u00e9cran d\u2019acceuil : || func kill_accueil() Permet de lib\u00e9rer l\u2019instance de maze : || func kill_maze() Permet de lib\u00e9rer l\u2019instance de l\u2019\u00e9cran de fin de partie : || func kill_endOfGame() G\u00e8re des instances de : EndOfGame , MainMenu et Maze","title":"Les killers permettent de lib\u00e9rer les instanciations"},{"location":"Player/","text":"Player.gd Ce script permet de g\u00e9rer les actions du joueur (son comportement et ses r\u00e9actions \u00e0 son environnement). Extends: [KinematicBody2D] Variables Relatives \u00e0 Maze Ces variables vont r\u00e9cup\u00e9rer les donn\u00e9es du parent de player : Maze R\u00e9cup\u00e9ration de la Maze d\u00e8s que la sc\u00e8ne Player est appel\u00e9e : || onready var Maze R\u00e9cup\u00e9ration de la position de la sortie du labyrinthe (mode Solo) depuis Maze : || var exitPos TileMap du labyrinthe : || var maze Pour stocker la taille de l\u2019\u00e9cran : || var screen_size Relatives au score Score du joueur (Mode Solo) : || var score Relatives au joueur Vitesse du joueur, initialis\u00e9 \u00e0 250 : || var speed Derni\u00e8re position du joueur (il est n\u00e9cessaire de la conna\u00eetre pour le bon fonctionnement des annimations), initialis\u00e9 \u00e0 0 (ce qui correspond \u00e0 la front view du personnage) : || var lastDirection Nombre de vies du joueur en mode solo, initialis\u00e9e \u00e0 3 : || var heart Identifiant (entier) du joueur instanci\u00e9 (utilis\u00e9 en mode Multi) : || var id Chargement et nom des animations des mouvements des joueurs Animations marcher vers le bas : || **var animDown Animation immobile vers le bas : || var animIdleFront Animation marcher vers le haut : || **var animUp Animation immobile vers le haut : || **var animIdleBack Animation marcher vers la gauche : || **var animLeft Animation immobile vers la gauche : || var animIdleLeft Animation marcher vers la droite : || **var animRight Animation immobile vers la droite : || var animIdleRight Relatives aux bombes D\u00e9claration de la sc\u00e8ne \u201cBombe\u201d en la chargeant depuis un path : || var Bombe Port\u00e9e de l\u2019explosion des instances de \u201cBombe\u201d, initialis\u00e9e \u00e0 2 : || var bombRange Tableau des bombes que le joueur poss\u00e8de: || var bombList Nombre d\u2019instances de \u201cBombe\u201d que le joueur peut poser, initialis\u00e9e \u00e0 2 : || var bombCapacity Relatives aux bonus Bool\u00e9en donnant la situation du bonus GodMode : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var invincible Bool\u00e9en donnant la situation du bonus Lumi\u00e8re : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var lumi Bool\u00e9en donnant la situation du bonus Nombre : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var nb Bool\u00e9en donnant la situation du bonus Pousser : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var pousse Bool\u00e9en donnant la situation du bonus Range : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var rang Bool\u00e9en donnant la situation du bonus Vitesse : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var vite Relatives \u00e0 la lumi\u00e8re Bool\u00e9en indiquant si la lumi\u00e8re est allum\u00e9e (= le bonus lumi\u00e8re est actif). Initialis\u00e9e \u00e0 true : || var light Mode de jeu Indique si la partie est en solo ou en multi, initialis\u00e9e \u00e0 true : || var isSingleplayer Commandes des joueurs Tableau des touches pour chaque joueur en fonction de son ID : || var keyMapping Fonctions Sc\u00e8ne Fonction appel\u00e9e quand le node entre pour la premi\u00e8re fois sur la sc\u00e8ne. On d\u00e9termine si nous sommes en solo ou en multijoueur et le cas \u00e9ch\u00e9ant on rajoute la restriction de lumi\u00e8re ou non : || func ready() Fonction appel\u00e9e \u00e0 chaque frame du jeu. Sert \u00e0 g\u00e9rer les d\u00e9placements, l\u2019arriv\u00e9e \u00e0 la sortie, les animations et la capacit\u00e9 de bombes : || func process(delta) Getters Fonction permettant de r\u00e9cup\u00e9rer le nombre de vie restant au joueur (utilis\u00e9e par HUD) : || func getHeart() Fonction permettant de savoir si le joueur a le bonus GodMode (utilis\u00e9e par HUD) : || func getInvincible() Fonction permettant de savoir si le joueur a le bonus Lumi\u00e8re (utilis\u00e9e par HUD) : || func getLumiere() Fonction permettant de savoir si le joueur a le bonus Nombre de Bombes (utilis\u00e9e par HUD) : || func getNb() Fonction permettant de savoir si le joueur a le bonus Pousser (utilis\u00e9e par HUD) : || func getPousse() Fonction permettant de savoir si le joueur a le bonus Port\u00e9e (utilis\u00e9e par HUD) : || func getRange() Fonction permettant de savoir si le joueur a le bonus Vitesse (utilis\u00e9e par HUD) : || func getVite() Relatives aux Bonus Fonction appel\u00e9e lorsque le joueur obtient le bonus GodMode. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis de rendre le joueur invincible pendant 5 secondes : || func godmode() Fonction appel\u00e9e lorsque le joueur obtient le bonus Lumi\u00e8re. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis de rendre la maze visible pendant 2 secondes : || func lumiere() Fonction appel\u00e9e lorsque le joueur obtient le bonus Nombre de Bombes. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis d\u2019augmenter le nombre de bombes que peut poser le joueur en m\u00eame temps : || func augmenteBombCapacity() Fonction appel\u00e9e lorsque le joueur obtient le bonus Pousser. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis de rendre les bombes pos\u00e9es par le joueur \u201cpoussables\u201d : || func pousseBombe() Fonction appel\u00e9e lorsque le joueur obtient le bonus Port\u00e9e. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis d\u2019augmenter la port\u00e9e des bombes pos\u00e9es par le joueur : || func augmenteRange() Fonction appel\u00e9e lorsque le joueur obtient le bonus Vitesse. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis d\u2019augmenter la vitesse du joueur de 100 : || func augmenteSpeed() Gestion du multijoueur Attribue un ID au joueur : || func setId() D\u00e9sactive la restriction de vision en multijoueur : || func disabledLight() Gestion des bombes et explosions Permet de poser une bombe. On instancie une bombe, on la place \u00e0 la position du joueur et si le joueur a le bonus Pousser on met la bombe en mode character : || func setup_bomb(bomb_name, pos) Fonction appel\u00e9e lorsqu\u2019on se fait toucher par une bombe. On v\u00e9rifie alors si le joueur est invincible, si ce n\u2019est pas le cas, alors soit il perd une vie soit il perd la partie le cas \u00e9chant : || func bombed() Fin de partie En cas de victoire, on pr\u00e9vient GameManager qu\u2019on a gagn\u00e9 : || func win() En cas de d\u00e9faite, on pr\u00e9vient GameManager, on joue le son de d\u00e9faite et on arr\u00eate la musique de jeu : || func lose()","title":"Player"},{"location":"Player/#playergd","text":"Ce script permet de g\u00e9rer les actions du joueur (son comportement et ses r\u00e9actions \u00e0 son environnement). Extends: [KinematicBody2D]","title":"Player.gd"},{"location":"Player/#variables","text":"","title":"Variables"},{"location":"Player/#relatives-a-maze","text":"Ces variables vont r\u00e9cup\u00e9rer les donn\u00e9es du parent de player : Maze R\u00e9cup\u00e9ration de la Maze d\u00e8s que la sc\u00e8ne Player est appel\u00e9e : || onready var Maze R\u00e9cup\u00e9ration de la position de la sortie du labyrinthe (mode Solo) depuis Maze : || var exitPos TileMap du labyrinthe : || var maze Pour stocker la taille de l\u2019\u00e9cran : || var screen_size","title":"Relatives \u00e0 Maze"},{"location":"Player/#relatives-au-score","text":"Score du joueur (Mode Solo) : || var score","title":"Relatives au score"},{"location":"Player/#relatives-au-joueur","text":"Vitesse du joueur, initialis\u00e9 \u00e0 250 : || var speed Derni\u00e8re position du joueur (il est n\u00e9cessaire de la conna\u00eetre pour le bon fonctionnement des annimations), initialis\u00e9 \u00e0 0 (ce qui correspond \u00e0 la front view du personnage) : || var lastDirection Nombre de vies du joueur en mode solo, initialis\u00e9e \u00e0 3 : || var heart Identifiant (entier) du joueur instanci\u00e9 (utilis\u00e9 en mode Multi) : || var id","title":"Relatives au joueur"},{"location":"Player/#chargement-et-nom-des-animations-des-mouvements-des-joueurs","text":"Animations marcher vers le bas : || **var animDown Animation immobile vers le bas : || var animIdleFront Animation marcher vers le haut : || **var animUp Animation immobile vers le haut : || **var animIdleBack Animation marcher vers la gauche : || **var animLeft Animation immobile vers la gauche : || var animIdleLeft Animation marcher vers la droite : || **var animRight Animation immobile vers la droite : || var animIdleRight","title":"Chargement et nom des animations des mouvements des joueurs"},{"location":"Player/#relatives-aux-bombes","text":"D\u00e9claration de la sc\u00e8ne \u201cBombe\u201d en la chargeant depuis un path : || var Bombe Port\u00e9e de l\u2019explosion des instances de \u201cBombe\u201d, initialis\u00e9e \u00e0 2 : || var bombRange Tableau des bombes que le joueur poss\u00e8de: || var bombList Nombre d\u2019instances de \u201cBombe\u201d que le joueur peut poser, initialis\u00e9e \u00e0 2 : || var bombCapacity","title":"Relatives aux bombes"},{"location":"Player/#relatives-aux-bonus","text":"Bool\u00e9en donnant la situation du bonus GodMode : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var invincible Bool\u00e9en donnant la situation du bonus Lumi\u00e8re : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var lumi Bool\u00e9en donnant la situation du bonus Nombre : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var nb Bool\u00e9en donnant la situation du bonus Pousser : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var pousse Bool\u00e9en donnant la situation du bonus Range : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var rang Bool\u00e9en donnant la situation du bonus Vitesse : s\u2019il est \u00e0 false le joueur n\u2019a pas le bonus et s\u2019il est \u00e0 true le joueur a le bonus. Initialis\u00e9e \u00e0 false : || var vite","title":"Relatives aux bonus"},{"location":"Player/#relatives-a-la-lumiere","text":"Bool\u00e9en indiquant si la lumi\u00e8re est allum\u00e9e (= le bonus lumi\u00e8re est actif). Initialis\u00e9e \u00e0 true : || var light","title":"Relatives \u00e0 la lumi\u00e8re"},{"location":"Player/#mode-de-jeu","text":"Indique si la partie est en solo ou en multi, initialis\u00e9e \u00e0 true : || var isSingleplayer","title":"Mode de jeu"},{"location":"Player/#commandes-des-joueurs","text":"Tableau des touches pour chaque joueur en fonction de son ID : || var keyMapping","title":"Commandes des joueurs"},{"location":"Player/#fonctions","text":"","title":"Fonctions"},{"location":"Player/#scene","text":"Fonction appel\u00e9e quand le node entre pour la premi\u00e8re fois sur la sc\u00e8ne. On d\u00e9termine si nous sommes en solo ou en multijoueur et le cas \u00e9ch\u00e9ant on rajoute la restriction de lumi\u00e8re ou non : || func ready() Fonction appel\u00e9e \u00e0 chaque frame du jeu. Sert \u00e0 g\u00e9rer les d\u00e9placements, l\u2019arriv\u00e9e \u00e0 la sortie, les animations et la capacit\u00e9 de bombes : || func process(delta)","title":"Sc\u00e8ne"},{"location":"Player/#getters","text":"Fonction permettant de r\u00e9cup\u00e9rer le nombre de vie restant au joueur (utilis\u00e9e par HUD) : || func getHeart() Fonction permettant de savoir si le joueur a le bonus GodMode (utilis\u00e9e par HUD) : || func getInvincible() Fonction permettant de savoir si le joueur a le bonus Lumi\u00e8re (utilis\u00e9e par HUD) : || func getLumiere() Fonction permettant de savoir si le joueur a le bonus Nombre de Bombes (utilis\u00e9e par HUD) : || func getNb() Fonction permettant de savoir si le joueur a le bonus Pousser (utilis\u00e9e par HUD) : || func getPousse() Fonction permettant de savoir si le joueur a le bonus Port\u00e9e (utilis\u00e9e par HUD) : || func getRange() Fonction permettant de savoir si le joueur a le bonus Vitesse (utilis\u00e9e par HUD) : || func getVite()","title":"Getters"},{"location":"Player/#relatives-aux-bonus_1","text":"Fonction appel\u00e9e lorsque le joueur obtient le bonus GodMode. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis de rendre le joueur invincible pendant 5 secondes : || func godmode() Fonction appel\u00e9e lorsque le joueur obtient le bonus Lumi\u00e8re. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis de rendre la maze visible pendant 2 secondes : || func lumiere() Fonction appel\u00e9e lorsque le joueur obtient le bonus Nombre de Bombes. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis d\u2019augmenter le nombre de bombes que peut poser le joueur en m\u00eame temps : || func augmenteBombCapacity() Fonction appel\u00e9e lorsque le joueur obtient le bonus Pousser. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis de rendre les bombes pos\u00e9es par le joueur \u201cpoussables\u201d : || func pousseBombe() Fonction appel\u00e9e lorsque le joueur obtient le bonus Port\u00e9e. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis d\u2019augmenter la port\u00e9e des bombes pos\u00e9es par le joueur : || func augmenteRange() Fonction appel\u00e9e lorsque le joueur obtient le bonus Vitesse. Elle permet d\u2019aumenter le score en cons\u00e9quence (+30 points pour l\u2019obtention d\u2019un bonus) puis d\u2019augmenter la vitesse du joueur de 100 : || func augmenteSpeed()","title":"Relatives aux Bonus"},{"location":"Player/#gestion-du-multijoueur","text":"Attribue un ID au joueur : || func setId() D\u00e9sactive la restriction de vision en multijoueur : || func disabledLight()","title":"Gestion du multijoueur"},{"location":"Player/#gestion-des-bombes-et-explosions","text":"Permet de poser une bombe. On instancie une bombe, on la place \u00e0 la position du joueur et si le joueur a le bonus Pousser on met la bombe en mode character : || func setup_bomb(bomb_name, pos) Fonction appel\u00e9e lorsqu\u2019on se fait toucher par une bombe. On v\u00e9rifie alors si le joueur est invincible, si ce n\u2019est pas le cas, alors soit il perd une vie soit il perd la partie le cas \u00e9chant : || func bombed()","title":"Gestion des bombes et explosions"},{"location":"Player/#fin-de-partie","text":"En cas de victoire, on pr\u00e9vient GameManager qu\u2019on a gagn\u00e9 : || func win() En cas de d\u00e9faite, on pr\u00e9vient GameManager, on joue le son de d\u00e9faite et on arr\u00eate la musique de jeu : || func lose()","title":"Fin de partie"},{"location":"Bonus/Bonus/","text":"Bonus.gd Ce script permet de g\u00e9rer les Bonus de mani\u00e8re g\u00e9n\u00e9ral (ind\u00e9pendant du type de bonus). Extends: [Area2D] Fonctions Collision Fonction appel\u00e9e quand un corps (Player) entre dans un bonus, cela lance un son (pour indiquer que le bonus est r\u00e9cup\u00e9r\u00e9) et le bonus dispara\u00eet de la Maze : || func on_Bonus_body_entered(player)","title":"Bonus"},{"location":"Bonus/Bonus/#bonusgd","text":"Ce script permet de g\u00e9rer les Bonus de mani\u00e8re g\u00e9n\u00e9ral (ind\u00e9pendant du type de bonus). Extends: [Area2D]","title":"Bonus.gd"},{"location":"Bonus/Bonus/#fonctions","text":"","title":"Fonctions"},{"location":"Bonus/Bonus/#collision","text":"Fonction appel\u00e9e quand un corps (Player) entre dans un bonus, cela lance un son (pour indiquer que le bonus est r\u00e9cup\u00e9r\u00e9) et le bonus dispara\u00eet de la Maze : || func on_Bonus_body_entered(player)","title":"Collision"},{"location":"Bonus/BonusGodMode/","text":"BonusGodMode.gd Ce script permet de g\u00e9rer le bonus GodMode. Le bonus GodMode rend le joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 invincible pendant quelques secondes. Extends: [Area2D] Fonctions Collision Fonction appel\u00e9e quand un corps entre dans un bonus d\u2019invincibilit\u00e9. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis rend le joueur invincible par la fonction correspondante : || func on_Bonus_body_entered(player)","title":"GodMod"},{"location":"Bonus/BonusGodMode/#bonusgodmodegd","text":"Ce script permet de g\u00e9rer le bonus GodMode. Le bonus GodMode rend le joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 invincible pendant quelques secondes. Extends: [Area2D]","title":"BonusGodMode.gd"},{"location":"Bonus/BonusGodMode/#fonctions","text":"","title":"Fonctions"},{"location":"Bonus/BonusGodMode/#collision","text":"Fonction appel\u00e9e quand un corps entre dans un bonus d\u2019invincibilit\u00e9. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis rend le joueur invincible par la fonction correspondante : || func on_Bonus_body_entered(player)","title":"Collision"},{"location":"Bonus/BonusLumiere/","text":"BonusLumiere.gd Ce script permet de g\u00e9rer le bonus Lumiere. Le bonus Lumiere permet au joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 de voir la maze en entier (seulement en mode Solo). Extends: [Area2D] Fonctions Collision Fonction appel\u00e9e quand un corps entre dans un bonus de lumi\u00e8re. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis rend le labyrinthe visible pendant quelques secondes (par la fonction correspondante) : || func on_Bonus_body_entered(player)","title":"Lumi\u00e8re"},{"location":"Bonus/BonusLumiere/#bonuslumieregd","text":"Ce script permet de g\u00e9rer le bonus Lumiere. Le bonus Lumiere permet au joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 de voir la maze en entier (seulement en mode Solo). Extends: [Area2D]","title":"BonusLumiere.gd"},{"location":"Bonus/BonusLumiere/#fonctions","text":"","title":"Fonctions"},{"location":"Bonus/BonusLumiere/#collision","text":"Fonction appel\u00e9e quand un corps entre dans un bonus de lumi\u00e8re. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis rend le labyrinthe visible pendant quelques secondes (par la fonction correspondante) : || func on_Bonus_body_entered(player)","title":"Collision"},{"location":"Bonus/BonusNombre/","text":"BonusNombre.gd Ce script permet de g\u00e9rer le bonus Nombre. Le bonus Nombre permet au joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 de poser une bombe de plus \u00e0 la fois sur la map. Extends: [Area2D] Fonctions Collision Fonction appel\u00e9e quand un corps entre dans un bonus de nombre de bombes. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis augmente le nombre de bombes pouvant \u00eatre pos\u00e9es par le joueur (par la fonction correspondante) : || func on_Bonus_body_entered(player)","title":"Capacit\u00e9"},{"location":"Bonus/BonusNombre/#bonusnombregd","text":"Ce script permet de g\u00e9rer le bonus Nombre. Le bonus Nombre permet au joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 de poser une bombe de plus \u00e0 la fois sur la map. Extends: [Area2D]","title":"BonusNombre.gd"},{"location":"Bonus/BonusNombre/#fonctions","text":"","title":"Fonctions"},{"location":"Bonus/BonusNombre/#collision","text":"Fonction appel\u00e9e quand un corps entre dans un bonus de nombre de bombes. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis augmente le nombre de bombes pouvant \u00eatre pos\u00e9es par le joueur (par la fonction correspondante) : || func on_Bonus_body_entered(player)","title":"Collision"},{"location":"Bonus/BonusPousser/","text":"BonusPousser.gd Ce script permet de g\u00e9rer le bonus Pousser. Le bonus Pousser rend les bombes du joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 \u2018poussables\u2019, de fait ses adversaires (Multi) ou ses ennemis (Solo) ainsi que lui-m\u00eame peuvent pousser ses bombes. Extends: [Area2D] Fonctions Collision Fonction appel\u00e9e quand un corps entre dans un bonus pousser. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis rend les bombes du joueur \u201cpoussables\u201d par la fonction correspondante : || func on_Bonus_body_entered(player)","title":"Pousser"},{"location":"Bonus/BonusPousser/#bonuspoussergd","text":"Ce script permet de g\u00e9rer le bonus Pousser. Le bonus Pousser rend les bombes du joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 \u2018poussables\u2019, de fait ses adversaires (Multi) ou ses ennemis (Solo) ainsi que lui-m\u00eame peuvent pousser ses bombes. Extends: [Area2D]","title":"BonusPousser.gd"},{"location":"Bonus/BonusPousser/#fonctions","text":"","title":"Fonctions"},{"location":"Bonus/BonusPousser/#collision","text":"Fonction appel\u00e9e quand un corps entre dans un bonus pousser. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis rend les bombes du joueur \u201cpoussables\u201d par la fonction correspondante : || func on_Bonus_body_entered(player)","title":"Collision"},{"location":"Bonus/BonusRange/","text":"BonusRange.gd Ce script permet de g\u00e9rer le bonus Range. Le bonus Range augmente la port\u00e9e des bombes pos\u00e9es par le joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9. Extends: [Area2D] Fonctions Collision Fonction appel\u00e9e quand un corps entre dans un bonus de port\u00e9e. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis augmente la port\u00e9e des bombes pos\u00e9es par le joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 par la fonction correspondante : || func on_Bonus_body_entered(player)","title":"Port\u00e9e"},{"location":"Bonus/BonusRange/#bonusrangegd","text":"Ce script permet de g\u00e9rer le bonus Range. Le bonus Range augmente la port\u00e9e des bombes pos\u00e9es par le joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9. Extends: [Area2D]","title":"BonusRange.gd"},{"location":"Bonus/BonusRange/#fonctions","text":"","title":"Fonctions"},{"location":"Bonus/BonusRange/#collision","text":"Fonction appel\u00e9e quand un corps entre dans un bonus de port\u00e9e. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis augmente la port\u00e9e des bombes pos\u00e9es par le joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 par la fonction correspondante : || func on_Bonus_body_entered(player)","title":"Collision"},{"location":"Bonus/BonusVitesse/","text":"BonusVitesse.gd Ce script permet de g\u00e9rer le bonus Vitesse. Le bonus Vitesse rend le joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 plus rapide. Extends: [Area2D] Fonctions Collision Fonction appel\u00e9e quand un corps entre dans un bonus de vitesse. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis rend le joueur plus rapide par la fonction correspondante : || func on_Bonus_body_entered(player)","title":"Vitesse"},{"location":"Bonus/BonusVitesse/#bonusvitessegd","text":"Ce script permet de g\u00e9rer le bonus Vitesse. Le bonus Vitesse rend le joueur l\u2019ayant r\u00e9cup\u00e9r\u00e9 plus rapide. Extends: [Area2D]","title":"BonusVitesse.gd"},{"location":"Bonus/BonusVitesse/#fonctions","text":"","title":"Fonctions"},{"location":"Bonus/BonusVitesse/#collision","text":"Fonction appel\u00e9e quand un corps entre dans un bonus de vitesse. Cette fonction v\u00e9rifie que le corps entr\u00e9 en collision avec ce bonus est un joueur (et non un ennemi) puis rend le joueur plus rapide par la fonction correspondante : || func on_Bonus_body_entered(player)","title":"Collision"},{"location":"IHM/EndOfGame/","text":"endOfGame.gd Ce script permet de g\u00e9rer les \u00e9crans de fin de partie, en solo ainsi qu\u2019en multijoueur. Extends: [Node] Variables Mode Solo Score du joueur mis \u00e0 jour au fur et \u00e0 mesure de la partie, initialis\u00e9e \u00e0 0 : || var score Tableau des textes de victoire en solo : || var victoryTexts Tableau des textes de d\u00e9faite en solo : || var lostTexts Mode Multi Stockage des noms des couleurs des joueurs : || var colors Tableau des textes de fin de partie (victoire) en multijoueur : || var multiEndTexts Tableau des textes de fin de partie en multijoueur en cas d\u2019\u00e9galit\u00e9 : || var multiDrawEndTexts Random Number Generator : || onready var rng Fonctions Sc\u00e8nes Fonction appel\u00e9e quand le node entre pour la premi\u00e8re fois sur la sc\u00e8ne, cache l\u2019\u00e9cran de fin de partie et g\u00e9n\u00e8re un nombre al\u00e9atoire : || func ready() Fonction ex\u00e9cut\u00e9e tout au long de l\u2019existence de la sc\u00e8ne. Ici elle permet de lancer une nouvelle partie d\u00e8s l\u2019appui sur la touche espace par le joueur : || func process(delta) Setters Fonction permettant de red\u00e9finir le score \u00e0 partir d\u2019une autre classe que endOfGame : || func set_score(player_score) Mode SOLO Fonction appel\u00e9e lors de la victoire du joueur et faisant appara\u00eetre l\u2019\u00e9cran de victoire (message s\u00e9lectionn\u00e9 al\u00e9atoirement dans la liste des messages de victoire solo, score & boutons \u201cNiveau Suivant\u201d & \u201cMenu\u201d) : || func on_Player_Victory() Fonction appel\u00e9e lors de la d\u00e9faite du joueur et faisant appara\u00eetre l\u2019\u00e9cran de d\u00e9faite (message s\u00e9lectionn\u00e9 al\u00e9atoirement dans la liste des messages de d\u00e9faite solo, score & boutons \u201cRejouer\u201d & \u201cMenu\u201d) : || func on_Player_Death() Mode MULTI Fonction appel\u00e9e lorsque la partie en multijoueur est termin\u00e9e et faisant appara\u00eetre l\u2019\u00e9cran de fin de partie multijoueurs (message s\u00e9lectionn\u00e9 al\u00e9atoirement dans la liste des messages de victoire d\u2019\u00e9galit\u00e9 multi (en fonction du r\u00e9sultat de la partie) & boutons \u201cRejouer\u201d & \u201cMenu\u201d): || func on_End_Multi(id_joueur) Gestion des boutons Fonction permettant de lancer la sc\u00e8ne de menu lorsque le joueur appui sur le bouton menu (elle permet \u00e9galement de g\u00e9rer les transitions du son entre les interfaces) : || func on_MenuButton_pressed() Fonction permettant de lancer la sc\u00e8ne de menu lorsque le joueur appui sur le bouton NextLevel (elle permet \u00e9galement de g\u00e9rer les transitions du son entre les interfaces) : || func on_NextLevelButton_pressed() Fonction permettant de g\u00e9n\u00e9rer un son lorsque la souris passe sur le bouton Menu : || func on_MenuButton_mouse_entered() Fonction permettant de g\u00e9n\u00e9rer un son lorsque la souris passe sur le bouton NextLevel : || func on_NextLevelButton_mouse_entered()","title":"EndOfGame"},{"location":"IHM/EndOfGame/#endofgamegd","text":"Ce script permet de g\u00e9rer les \u00e9crans de fin de partie, en solo ainsi qu\u2019en multijoueur. Extends: [Node]","title":"endOfGame.gd"},{"location":"IHM/EndOfGame/#variables","text":"","title":"Variables"},{"location":"IHM/EndOfGame/#mode-solo","text":"Score du joueur mis \u00e0 jour au fur et \u00e0 mesure de la partie, initialis\u00e9e \u00e0 0 : || var score Tableau des textes de victoire en solo : || var victoryTexts Tableau des textes de d\u00e9faite en solo : || var lostTexts","title":"Mode Solo"},{"location":"IHM/EndOfGame/#mode-multi","text":"Stockage des noms des couleurs des joueurs : || var colors Tableau des textes de fin de partie (victoire) en multijoueur : || var multiEndTexts Tableau des textes de fin de partie en multijoueur en cas d\u2019\u00e9galit\u00e9 : || var multiDrawEndTexts Random Number Generator : || onready var rng","title":"Mode Multi"},{"location":"IHM/EndOfGame/#fonctions","text":"","title":"Fonctions"},{"location":"IHM/EndOfGame/#scenes","text":"Fonction appel\u00e9e quand le node entre pour la premi\u00e8re fois sur la sc\u00e8ne, cache l\u2019\u00e9cran de fin de partie et g\u00e9n\u00e8re un nombre al\u00e9atoire : || func ready() Fonction ex\u00e9cut\u00e9e tout au long de l\u2019existence de la sc\u00e8ne. Ici elle permet de lancer une nouvelle partie d\u00e8s l\u2019appui sur la touche espace par le joueur : || func process(delta)","title":"Sc\u00e8nes"},{"location":"IHM/EndOfGame/#setters","text":"Fonction permettant de red\u00e9finir le score \u00e0 partir d\u2019une autre classe que endOfGame : || func set_score(player_score)","title":"Setters"},{"location":"IHM/EndOfGame/#mode-solo_1","text":"Fonction appel\u00e9e lors de la victoire du joueur et faisant appara\u00eetre l\u2019\u00e9cran de victoire (message s\u00e9lectionn\u00e9 al\u00e9atoirement dans la liste des messages de victoire solo, score & boutons \u201cNiveau Suivant\u201d & \u201cMenu\u201d) : || func on_Player_Victory() Fonction appel\u00e9e lors de la d\u00e9faite du joueur et faisant appara\u00eetre l\u2019\u00e9cran de d\u00e9faite (message s\u00e9lectionn\u00e9 al\u00e9atoirement dans la liste des messages de d\u00e9faite solo, score & boutons \u201cRejouer\u201d & \u201cMenu\u201d) : || func on_Player_Death()","title":"Mode SOLO"},{"location":"IHM/EndOfGame/#mode-multi_1","text":"Fonction appel\u00e9e lorsque la partie en multijoueur est termin\u00e9e et faisant appara\u00eetre l\u2019\u00e9cran de fin de partie multijoueurs (message s\u00e9lectionn\u00e9 al\u00e9atoirement dans la liste des messages de victoire d\u2019\u00e9galit\u00e9 multi (en fonction du r\u00e9sultat de la partie) & boutons \u201cRejouer\u201d & \u201cMenu\u201d): || func on_End_Multi(id_joueur)","title":"Mode MULTI"},{"location":"IHM/EndOfGame/#gestion-des-boutons","text":"Fonction permettant de lancer la sc\u00e8ne de menu lorsque le joueur appui sur le bouton menu (elle permet \u00e9galement de g\u00e9rer les transitions du son entre les interfaces) : || func on_MenuButton_pressed() Fonction permettant de lancer la sc\u00e8ne de menu lorsque le joueur appui sur le bouton NextLevel (elle permet \u00e9galement de g\u00e9rer les transitions du son entre les interfaces) : || func on_NextLevelButton_pressed() Fonction permettant de g\u00e9n\u00e9rer un son lorsque la souris passe sur le bouton Menu : || func on_MenuButton_mouse_entered() Fonction permettant de g\u00e9n\u00e9rer un son lorsque la souris passe sur le bouton NextLevel : || func on_NextLevelButton_mouse_entered()","title":"Gestion des boutons"},{"location":"IHM/HUD/","text":"HUD.gd Ce script permet d\u2019afficher le HUD qui comporte les coeurs repr\u00e9sentant la vie du joueur ainsi que les bonus acquis par le joueur au cours de la partie. Extends: [Control] Variables Joueur pr\u00e9sent sur la maze (mode SOLO) : || var player Bool\u00e9en permettant de savoir si le joueur est bien charg\u00e9 sur la maze (initialis\u00e9 \u00e0 false ): || var loaded Fonctions Sc\u00e8nes Fonction appel\u00e9e quand le node entre pour la premi\u00e8re fois sur la sc\u00e8ne, elle permet de cacher les bonus pr\u00e9sents dans le HUD (i.e. au d\u00e9part le joueur n\u2019a aucun bonus) : || func ready() Fonction ex\u00e9cut\u00e9e tout au long de l\u2019existence de la sc\u00e8ne. Ici elle permet de mettre \u00e0 jour le HUD en fonction des actions du joueur : s\u2019il perd une vie un coeur dispara\u00eet, s\u2019il r\u00e9cup\u00e8re un bonus, le bonus en question s\u2019affiche dans le HUD (si le bonus est temporaire, il dispara\u00eet du HUD lorsque le temps d\u2019action du bonus est \u00e9coul\u00e9): || func process(delta) NB : Si le joueur n\u2019a plus de vie dans le HUD, son instance est lib\u00e9r\u00e9e de la Maze. Getters Fonction appel\u00e9e pour r\u00e9cup\u00e9rer le joueur (si le joueur est r\u00e9cup\u00e9r\u00e9, loaded passe \u00e0 true ): || func getPlayer(p)","title":"HUD"},{"location":"IHM/HUD/#hudgd","text":"Ce script permet d\u2019afficher le HUD qui comporte les coeurs repr\u00e9sentant la vie du joueur ainsi que les bonus acquis par le joueur au cours de la partie. Extends: [Control]","title":"HUD.gd"},{"location":"IHM/HUD/#variables","text":"Joueur pr\u00e9sent sur la maze (mode SOLO) : || var player Bool\u00e9en permettant de savoir si le joueur est bien charg\u00e9 sur la maze (initialis\u00e9 \u00e0 false ): || var loaded","title":"Variables"},{"location":"IHM/HUD/#fonctions","text":"","title":"Fonctions"},{"location":"IHM/HUD/#scenes","text":"Fonction appel\u00e9e quand le node entre pour la premi\u00e8re fois sur la sc\u00e8ne, elle permet de cacher les bonus pr\u00e9sents dans le HUD (i.e. au d\u00e9part le joueur n\u2019a aucun bonus) : || func ready() Fonction ex\u00e9cut\u00e9e tout au long de l\u2019existence de la sc\u00e8ne. Ici elle permet de mettre \u00e0 jour le HUD en fonction des actions du joueur : s\u2019il perd une vie un coeur dispara\u00eet, s\u2019il r\u00e9cup\u00e8re un bonus, le bonus en question s\u2019affiche dans le HUD (si le bonus est temporaire, il dispara\u00eet du HUD lorsque le temps d\u2019action du bonus est \u00e9coul\u00e9): || func process(delta) NB : Si le joueur n\u2019a plus de vie dans le HUD, son instance est lib\u00e9r\u00e9e de la Maze.","title":"Sc\u00e8nes"},{"location":"IHM/HUD/#getters","text":"Fonction appel\u00e9e pour r\u00e9cup\u00e9rer le joueur (si le joueur est r\u00e9cup\u00e9r\u00e9, loaded passe \u00e0 true ): || func getPlayer(p)","title":"Getters"},{"location":"IHM/MainMenu/","text":"MainMenu.gd Ce script permet de g\u00e9rer l\u2019\u00e9cran d\u2019accueil du jeu. Extends: [Control] Fonctions Sc\u00e8nes Lorsque le menu d\u2019accueil appara\u00eet les boutons indiquant le nombre de joueurs n\u2019appara\u00eessent pas : || func ready() Mode SOLO Lorsque le joueur appui sur le bouton \u201cSOLO GAME\u201d, on lance le maze et on lib\u00e8re le menu d\u2019accueil. On en profite aussi pour jouer le son de validation du bouton, et la musique de jeu solo : || func on_Solo_pressed() Mode MULTI Lorsque le joueur appui sur le bouton \u201cMULTIJOUEUR\u201d, on affiche les boutons indiquant le nombre de joueurs : || func on_Multi_pressed(id_joueur) Si le joueur appuie maintenant sur le bouton \u201c2\u201d, on lance une partie \u00e0 2 joueurs. On en profite aussi pour jouer le son de validation du bouton, et la musique de jeu multi : || func on_two_pressed(id_joueur) Si le joueur appuie maintenant sur le bouton \u201c3\u201d, on lance une partie \u00e0 3 joueurs. On en profite aussi pour jouer le son de validation du bouton, et la musique de jeu multi : || func on_three_pressed(id_joueur) Si le joueur appuie maintenant sur le bouton \u201c4\u201d, on lance une partie \u00e0 4 joueurs. On en profite aussi pour jouer le son de validation du bouton, et la musique de jeu multi : || func on_four_pressed(id_joueur) Gestion des sons Fonction permettant de d\u00e9clencher un son lorsque la souris du joueur entre dans le cadre du bouton \u201cSOLO\u201d : || func on_Solo_mouse_entered() Fonction permettant de d\u00e9clencher un son lorsque la souris du joueur entre dans le cadre du bouton \u201cMULTI\u201d : || func on_Multi_mouse_entered() Fonction permettant de d\u00e9clencher un son lorsque la souris du joueur entre dans le cadre du bouton \u201c2\u201d : || func on_two_mouse_entered() Fonction permettant de d\u00e9clencher un son lorsque la souris du joueur entre dans le cadre du bouton \u201c3\u201d : || func on_three_mouse_entered() Fonction permettant de d\u00e9clencher un son lorsque la souris du joueur entre dans le cadre du bouton \u201c4\u201d : || func on_four_mouse_entered()","title":"MainMenu"},{"location":"IHM/MainMenu/#mainmenugd","text":"Ce script permet de g\u00e9rer l\u2019\u00e9cran d\u2019accueil du jeu. Extends: [Control]","title":"MainMenu.gd"},{"location":"IHM/MainMenu/#fonctions","text":"","title":"Fonctions"},{"location":"IHM/MainMenu/#scenes","text":"Lorsque le menu d\u2019accueil appara\u00eet les boutons indiquant le nombre de joueurs n\u2019appara\u00eessent pas : || func ready()","title":"Sc\u00e8nes"},{"location":"IHM/MainMenu/#mode-solo","text":"Lorsque le joueur appui sur le bouton \u201cSOLO GAME\u201d, on lance le maze et on lib\u00e8re le menu d\u2019accueil. On en profite aussi pour jouer le son de validation du bouton, et la musique de jeu solo : || func on_Solo_pressed()","title":"Mode SOLO"},{"location":"IHM/MainMenu/#mode-multi","text":"Lorsque le joueur appui sur le bouton \u201cMULTIJOUEUR\u201d, on affiche les boutons indiquant le nombre de joueurs : || func on_Multi_pressed(id_joueur) Si le joueur appuie maintenant sur le bouton \u201c2\u201d, on lance une partie \u00e0 2 joueurs. On en profite aussi pour jouer le son de validation du bouton, et la musique de jeu multi : || func on_two_pressed(id_joueur) Si le joueur appuie maintenant sur le bouton \u201c3\u201d, on lance une partie \u00e0 3 joueurs. On en profite aussi pour jouer le son de validation du bouton, et la musique de jeu multi : || func on_three_pressed(id_joueur) Si le joueur appuie maintenant sur le bouton \u201c4\u201d, on lance une partie \u00e0 4 joueurs. On en profite aussi pour jouer le son de validation du bouton, et la musique de jeu multi : || func on_four_pressed(id_joueur)","title":"Mode MULTI"},{"location":"IHM/MainMenu/#gestion-des-sons","text":"Fonction permettant de d\u00e9clencher un son lorsque la souris du joueur entre dans le cadre du bouton \u201cSOLO\u201d : || func on_Solo_mouse_entered() Fonction permettant de d\u00e9clencher un son lorsque la souris du joueur entre dans le cadre du bouton \u201cMULTI\u201d : || func on_Multi_mouse_entered() Fonction permettant de d\u00e9clencher un son lorsque la souris du joueur entre dans le cadre du bouton \u201c2\u201d : || func on_two_mouse_entered() Fonction permettant de d\u00e9clencher un son lorsque la souris du joueur entre dans le cadre du bouton \u201c3\u201d : || func on_three_mouse_entered() Fonction permettant de d\u00e9clencher un son lorsque la souris du joueur entre dans le cadre du bouton \u201c4\u201d : || func on_four_mouse_entered()","title":"Gestion des sons"},{"location":"Maze/BonusWall/","text":"BonusWall.gd Ce script permet de g\u00e9rer les murs cassables contenant des bonus (principalement leur apparence et leur destruction). Extends: [KinematicBody2D] Variables Chargement des sc\u00e8nes des diff\u00e9rents bonus Chargement de la sc\u00e8ne du bonus vitesse : || var bonusVitesse Chargement de la sc\u00e8ne du bonus port\u00e9e : || var bonusRange Chargement de la sc\u00e8ne du bonus pousser : || var bonusPousser Chargement de la sc\u00e8ne du bonus de nombre de bombes : || var bonusNombre Chargement de la sc\u00e8ne du bonus lumi\u00e8re : || var bonusLumiere Chargement de la sc\u00e8ne du bonus God Mode : || var bonusGodMode Mode de jeu Indique si le mode de jeu est en solo : || var solo Fonctions Sc\u00e8nes Fonction lanc\u00e9e \u00e0 l\u2019initialisation du mur cassable avec bonus, servant \u00e0 donner une texture de d\u00e9part al\u00e9atoire pour que les cycles de tous les murs cassables ne soient pas synchronis\u00e9s. On en profite pour rendre impossible l\u2019obtention du bonus lumi\u00e8re en multijoueur : || func ready() Destruction du mur Fonction appel\u00e9e lorsque le mur est d\u00e9truit par une bombe, on fait donc apara\u00eetre un objet bonus en fonction de la texture qu\u2019avait le mur au moment d\u2019\u00eatre d\u00e9truit : || func bombed()","title":"BonusWall"},{"location":"Maze/BonusWall/#bonuswallgd","text":"Ce script permet de g\u00e9rer les murs cassables contenant des bonus (principalement leur apparence et leur destruction). Extends: [KinematicBody2D]","title":"BonusWall.gd"},{"location":"Maze/BonusWall/#variables","text":"","title":"Variables"},{"location":"Maze/BonusWall/#chargement-des-scenes-des-differents-bonus","text":"Chargement de la sc\u00e8ne du bonus vitesse : || var bonusVitesse Chargement de la sc\u00e8ne du bonus port\u00e9e : || var bonusRange Chargement de la sc\u00e8ne du bonus pousser : || var bonusPousser Chargement de la sc\u00e8ne du bonus de nombre de bombes : || var bonusNombre Chargement de la sc\u00e8ne du bonus lumi\u00e8re : || var bonusLumiere Chargement de la sc\u00e8ne du bonus God Mode : || var bonusGodMode","title":"Chargement des sc\u00e8nes des diff\u00e9rents bonus"},{"location":"Maze/BonusWall/#mode-de-jeu","text":"Indique si le mode de jeu est en solo : || var solo","title":"Mode de jeu"},{"location":"Maze/BonusWall/#fonctions","text":"","title":"Fonctions"},{"location":"Maze/BonusWall/#scenes","text":"Fonction lanc\u00e9e \u00e0 l\u2019initialisation du mur cassable avec bonus, servant \u00e0 donner une texture de d\u00e9part al\u00e9atoire pour que les cycles de tous les murs cassables ne soient pas synchronis\u00e9s. On en profite pour rendre impossible l\u2019obtention du bonus lumi\u00e8re en multijoueur : || func ready()","title":"Sc\u00e8nes"},{"location":"Maze/BonusWall/#destruction-du-mur","text":"Fonction appel\u00e9e lorsque le mur est d\u00e9truit par une bombe, on fait donc apara\u00eetre un objet bonus en fonction de la texture qu\u2019avait le mur au moment d\u2019\u00eatre d\u00e9truit : || func bombed()","title":"Destruction du mur"},{"location":"Maze/Maze/","text":"Maze.gd Ce script permet de g\u00e9rer la sc\u00e8ne maze, construire le labyrinthe et instancier les joueurs, ennemis.... Extends: Node Variables D\u00e9claration des diff\u00e9rentes sc\u00e8nes en les chargeant depuis un path Chargement de la sc\u00e8ne d\u2019ennemis : || var Enemy Chargement de la sc\u00e8ne de bonus Vitesse : || var bonusVitesse Chargement de la sc\u00e8ne de bonus Range : || var bonusRange Chargement de la sc\u00e8ne de bonus Pousser : || var bonusPousser Chargement de la sc\u00e8ne de bonus Nombre : || var bonusNombre Chargement de la sc\u00e8ne de bonus Lumiere : || var bonusLumiere Chargement de la sc\u00e8ne de bonus GodMode : || var bonusGodMode Chargement de la sc\u00e8ne de mur cassable : || var caillou Chargement de la sc\u00e8ne de mur cassables contenant des bonus : || var bonusWall Chargement de la sc\u00e8ne de joueur : || var player_model R\u00e9f\u00e9rences \u00e0 d\u2019autres objets/sc\u00e8nes R\u00e9f\u00e9rence \u00e0 la TileMap du labyrinthe : || onready var maze G\u00e9n\u00e9rateur de nombre al\u00e9atoire : || onready var rng R\u00e9cup\u00e9ration des donn\u00e9es de GameManager : || onready var GameManager Difficult\u00e9 de la maze r\u00e9cup\u00e9r\u00e9e dans le GameManager : || onready var difficulty Nombre de joueur \u00e0 instancier sur la maze, r\u00e9cup\u00e9r\u00e9 dans le GameManager : || onready var nb_player D\u00e9claration des images de murs cassables en les chargeant depuis un path Chargement de l\u2019image de mur cassable 1 : || var wall1 Chargement de l\u2019image de mur cassable 2 : || var wall2 Chargement de l\u2019image de mur cassable 3 : || var wall3 Chargement de l\u2019image de mur cassable 4 : || var wall4 Param\u00e8tres de g\u00e9n\u00e9ration du maze Longueur ext\u00e9rieure du labyrinthe en cases, initialis\u00e9e \u00e0 15 : || var length Largeur ext\u00e9rieure du labyrinthe en cases, initialis\u00e9e \u00e0 13 : || var width Multiplicateur de lenteur de g\u00e9n\u00e9ration (> 0, + petit = + rapide), initialis\u00e9 \u00e0 1 : || var genSpeed Probabilit\u00e9 minimum de faire apparaitre un mur (difficult\u00e9 faible), initialis\u00e9 \u00e0 0.2 : || var probaWallMin Probabilit\u00e9 maximum de faire apparaitre un mur (difficult\u00e9 forte), initialis\u00e9 \u00e0 0.95 : || var probaWallMax Probabilit\u00e9 de base de cr\u00e9er un chemin pour un ennemi, initialis\u00e9 \u00e0 0.6 : || var baseProbaEnemyPath Probabilit\u00e9 retir\u00e9e \u00e0 la pr\u00e9c\u00e9dente chaque tour, initialis\u00e9 \u00e0 0.15 : || var minusProbaEachTurn Distance minimale requise entre le point de spawn et la sortie, initialis\u00e9e \u00e0 8 : || var distanceMinSpawnExit Distance minimale requise entre le spawn et un ennemi, initialis\u00e9e \u00e0 5 : || var distanceMinSpawnEnemy Nombre maximal d\u2019ennemis, initialis\u00e9 \u00e0 7 : || var nbMaxEnemy Probabilit\u00e9 de base d\u2019avoir un mur cassable avec bonus au lieu d\u2019un mur cassable lambda, initialis\u00e9 \u00e0 0.2 : || var probaBonus [Debug] Ennemis activ\u00e9s: || var spawnEnnemies [Debug] Murs cassables activ\u00e9s 1 : || var spawnWalls [Debug] Apparition de la sortie : || var spawnExit Identifiants des tiles que l\u2019on souhaite placer Identifiant des blocs de murs incassables (tableau): || var obsidian Identifiant du sol : || var sol Identifiant de la sortie : || var exit Variables globales Probabilit\u00e9 d\u2019avoir un mur cassable sur une case : || var probaWall Position du spawn : || var spawnPos Position de la sortie : || var exitPos Tableau des positions des spawns des joueurs : || var playersSpawnPositions Liste des joueurs : || var playersList Tableau des positions de spawn des ennemis : || var enemyPositions Nombre d\u2019ennemis : || var nbEnemy Tableau des murs cassables dans le labyrinthe : || var walls Tableau des textures des diff\u00e9rents murs cassables : || var textWalls Joueur : || var player Si le labyrinthe est charg\u00e9 ou non, initialis\u00e9 \u00e0 false : || var loaded Fonctions Sc\u00e8nes Fonction lanc\u00e9e \u00e0 l\u2019initialisation de la sc\u00e8ne de labyrinthe sert \u00e0 jouer la musique du mode de jeu choisi, d\u00e9sactive les ennemis et la sortie si le mode de jeu est en multi. Puis initialise le labyrinthe : || func ready() Fonction lanc\u00e9e \u00e0 chaque frame du labyrinthe, sert \u00e0 d\u00e9tecter quand un joueur est mort : || func process(delta) G\u00e9n\u00e9ration du labyrinthe Retourne un tableau contenant les positions des murs cassables du labyrinthe : || func getWallsPos() Renvoie la distance de manhattan entre deux points : || func manhattan(a : Vector2, b : Vector2) Renvoie la probabilit\u00e9 d\u2019avoir un mur cassable \u00e0 une position en fonction de la difficult\u00e9. Et des param\u00e8tres de g\u00e9n\u00e9ration comme la probabilit\u00e9 minimale d\u2019avoir un mur cassable : || func getNewProba() Renvoie si un point est dans le labyrinthe ou non : || func isInBounds(pos : Vector2) Renvoie le nombre d\u2019ennemis qu\u2019il doit y avoir dans le labyrinthe en fonction de la difficult\u00e9, et des param\u00e8tres de g\u00e9n\u00e9ration comme nbMaxEnemy. Il y a aussi al\u00e9atoirement 1 ennemi en plus ou en moins : || func getNbEnemy() Permet de g\u00e9n\u00e9rer un labyrinthe avec : Des murs incassables selon un pattern donn\u00e9 Des murs cassables al\u00e9atoirement selon la difficult\u00e9 Des murs cassables contenants un bonus al\u00e9atoirement Un point de spawn dans un des coins du labyrinthe Une sortie Des ennemis selon la difficult\u00e9, ayant une position et un type al\u00e9atoire Une gestion du multijoueur (pas de HUD, + de bonus, pas d\u2019ennemis ni de sortie,\u2026) Et suivant certaines r\u00e8gles : Il y a 3 cases vides dans le coin du spawn (pour pouvoir poser une bombe) La sortie est \u00e0 + de distanceMinSpawnExit cases (manhattan) du spawn Il n\u2019y a pas d\u2019ennemi \u00e0 - de distanceMinSpawnEnemy case du spawn : \u2014 || func initMaze(nbPlayer : int) Fonction servant \u00e0 instancier, initialiser et placer le(s) joueur(s) qui vont jouer et prenant le nombre de joueurs en param\u00e8tres: || func initPlayers() Instancie, initialise et place les ennemis \u00e0 partir de la liste des ennemis : || func initEnemy() Fonction r\u00e9cursive permettant de cr\u00e9er un chemin al\u00e9atoirement dans le labyrinthe case par case pour les ennemis, \u00e0 chaque nouvel appel la probabilit\u00e9 de rallonger le chemin diminue : || func alterPath(pos : Vector2, proba : float) Fonction r\u00e9cursive permettant de cr\u00e9er un chemin al\u00e9atoirement dans le labyrinthe case par case pour les ennemis, \u00e0 chaque nouvel appel la probabilit\u00e9 de rallonger le chemin diminue : || func alterPath(pos : Vector2, proba : float) Renvoie toutes les combinaisons possibles entre plusieurs listes d\u2019un tableau de listes : || func combinaisons(a) G\u00e8re des instances de : Player , Wall , Bonus , BonusRange , BonusNombre , BonusPousser , BonusLumiere , BonusGodMode , BonusVitesse , HUD","title":"Maze"},{"location":"Maze/Maze/#mazegd","text":"Ce script permet de g\u00e9rer la sc\u00e8ne maze, construire le labyrinthe et instancier les joueurs, ennemis.... Extends: Node","title":"Maze.gd"},{"location":"Maze/Maze/#variables","text":"","title":"Variables"},{"location":"Maze/Maze/#declaration-des-differentes-scenes-en-les-chargeant-depuis-un-path","text":"Chargement de la sc\u00e8ne d\u2019ennemis : || var Enemy Chargement de la sc\u00e8ne de bonus Vitesse : || var bonusVitesse Chargement de la sc\u00e8ne de bonus Range : || var bonusRange Chargement de la sc\u00e8ne de bonus Pousser : || var bonusPousser Chargement de la sc\u00e8ne de bonus Nombre : || var bonusNombre Chargement de la sc\u00e8ne de bonus Lumiere : || var bonusLumiere Chargement de la sc\u00e8ne de bonus GodMode : || var bonusGodMode Chargement de la sc\u00e8ne de mur cassable : || var caillou Chargement de la sc\u00e8ne de mur cassables contenant des bonus : || var bonusWall Chargement de la sc\u00e8ne de joueur : || var player_model","title":"D\u00e9claration des diff\u00e9rentes sc\u00e8nes en les chargeant depuis un path"},{"location":"Maze/Maze/#references-a-dautres-objetsscenes","text":"R\u00e9f\u00e9rence \u00e0 la TileMap du labyrinthe : || onready var maze G\u00e9n\u00e9rateur de nombre al\u00e9atoire : || onready var rng R\u00e9cup\u00e9ration des donn\u00e9es de GameManager : || onready var GameManager Difficult\u00e9 de la maze r\u00e9cup\u00e9r\u00e9e dans le GameManager : || onready var difficulty Nombre de joueur \u00e0 instancier sur la maze, r\u00e9cup\u00e9r\u00e9 dans le GameManager : || onready var nb_player","title":"R\u00e9f\u00e9rences \u00e0 d'autres objets/sc\u00e8nes"},{"location":"Maze/Maze/#declaration-des-images-de-murs-cassables-en-les-chargeant-depuis-un-path","text":"Chargement de l\u2019image de mur cassable 1 : || var wall1 Chargement de l\u2019image de mur cassable 2 : || var wall2 Chargement de l\u2019image de mur cassable 3 : || var wall3 Chargement de l\u2019image de mur cassable 4 : || var wall4","title":"D\u00e9claration des images de murs cassables en les chargeant depuis un path"},{"location":"Maze/Maze/#parametres-de-generation-du-maze","text":"Longueur ext\u00e9rieure du labyrinthe en cases, initialis\u00e9e \u00e0 15 : || var length Largeur ext\u00e9rieure du labyrinthe en cases, initialis\u00e9e \u00e0 13 : || var width Multiplicateur de lenteur de g\u00e9n\u00e9ration (> 0, + petit = + rapide), initialis\u00e9 \u00e0 1 : || var genSpeed Probabilit\u00e9 minimum de faire apparaitre un mur (difficult\u00e9 faible), initialis\u00e9 \u00e0 0.2 : || var probaWallMin Probabilit\u00e9 maximum de faire apparaitre un mur (difficult\u00e9 forte), initialis\u00e9 \u00e0 0.95 : || var probaWallMax Probabilit\u00e9 de base de cr\u00e9er un chemin pour un ennemi, initialis\u00e9 \u00e0 0.6 : || var baseProbaEnemyPath Probabilit\u00e9 retir\u00e9e \u00e0 la pr\u00e9c\u00e9dente chaque tour, initialis\u00e9 \u00e0 0.15 : || var minusProbaEachTurn Distance minimale requise entre le point de spawn et la sortie, initialis\u00e9e \u00e0 8 : || var distanceMinSpawnExit Distance minimale requise entre le spawn et un ennemi, initialis\u00e9e \u00e0 5 : || var distanceMinSpawnEnemy Nombre maximal d\u2019ennemis, initialis\u00e9 \u00e0 7 : || var nbMaxEnemy Probabilit\u00e9 de base d\u2019avoir un mur cassable avec bonus au lieu d\u2019un mur cassable lambda, initialis\u00e9 \u00e0 0.2 : || var probaBonus [Debug] Ennemis activ\u00e9s: || var spawnEnnemies [Debug] Murs cassables activ\u00e9s 1 : || var spawnWalls [Debug] Apparition de la sortie : || var spawnExit","title":"Param\u00e8tres de g\u00e9n\u00e9ration du maze"},{"location":"Maze/Maze/#identifiants-des-tiles-que-lon-souhaite-placer","text":"Identifiant des blocs de murs incassables (tableau): || var obsidian Identifiant du sol : || var sol Identifiant de la sortie : || var exit","title":"Identifiants des tiles que l'on souhaite placer"},{"location":"Maze/Maze/#variables-globales","text":"Probabilit\u00e9 d\u2019avoir un mur cassable sur une case : || var probaWall Position du spawn : || var spawnPos Position de la sortie : || var exitPos Tableau des positions des spawns des joueurs : || var playersSpawnPositions Liste des joueurs : || var playersList Tableau des positions de spawn des ennemis : || var enemyPositions Nombre d\u2019ennemis : || var nbEnemy Tableau des murs cassables dans le labyrinthe : || var walls Tableau des textures des diff\u00e9rents murs cassables : || var textWalls Joueur : || var player Si le labyrinthe est charg\u00e9 ou non, initialis\u00e9 \u00e0 false : || var loaded","title":"Variables globales"},{"location":"Maze/Maze/#fonctions","text":"","title":"Fonctions"},{"location":"Maze/Maze/#scenes","text":"Fonction lanc\u00e9e \u00e0 l\u2019initialisation de la sc\u00e8ne de labyrinthe sert \u00e0 jouer la musique du mode de jeu choisi, d\u00e9sactive les ennemis et la sortie si le mode de jeu est en multi. Puis initialise le labyrinthe : || func ready() Fonction lanc\u00e9e \u00e0 chaque frame du labyrinthe, sert \u00e0 d\u00e9tecter quand un joueur est mort : || func process(delta)","title":"Sc\u00e8nes"},{"location":"Maze/Maze/#generation-du-labyrinthe","text":"Retourne un tableau contenant les positions des murs cassables du labyrinthe : || func getWallsPos() Renvoie la distance de manhattan entre deux points : || func manhattan(a : Vector2, b : Vector2) Renvoie la probabilit\u00e9 d\u2019avoir un mur cassable \u00e0 une position en fonction de la difficult\u00e9. Et des param\u00e8tres de g\u00e9n\u00e9ration comme la probabilit\u00e9 minimale d\u2019avoir un mur cassable : || func getNewProba() Renvoie si un point est dans le labyrinthe ou non : || func isInBounds(pos : Vector2) Renvoie le nombre d\u2019ennemis qu\u2019il doit y avoir dans le labyrinthe en fonction de la difficult\u00e9, et des param\u00e8tres de g\u00e9n\u00e9ration comme nbMaxEnemy. Il y a aussi al\u00e9atoirement 1 ennemi en plus ou en moins : || func getNbEnemy() Permet de g\u00e9n\u00e9rer un labyrinthe avec : Des murs incassables selon un pattern donn\u00e9 Des murs cassables al\u00e9atoirement selon la difficult\u00e9 Des murs cassables contenants un bonus al\u00e9atoirement Un point de spawn dans un des coins du labyrinthe Une sortie Des ennemis selon la difficult\u00e9, ayant une position et un type al\u00e9atoire Une gestion du multijoueur (pas de HUD, + de bonus, pas d\u2019ennemis ni de sortie,\u2026) Et suivant certaines r\u00e8gles : Il y a 3 cases vides dans le coin du spawn (pour pouvoir poser une bombe) La sortie est \u00e0 + de distanceMinSpawnExit cases (manhattan) du spawn Il n\u2019y a pas d\u2019ennemi \u00e0 - de distanceMinSpawnEnemy case du spawn : \u2014 || func initMaze(nbPlayer : int) Fonction servant \u00e0 instancier, initialiser et placer le(s) joueur(s) qui vont jouer et prenant le nombre de joueurs en param\u00e8tres: || func initPlayers() Instancie, initialise et place les ennemis \u00e0 partir de la liste des ennemis : || func initEnemy() Fonction r\u00e9cursive permettant de cr\u00e9er un chemin al\u00e9atoirement dans le labyrinthe case par case pour les ennemis, \u00e0 chaque nouvel appel la probabilit\u00e9 de rallonger le chemin diminue : || func alterPath(pos : Vector2, proba : float) Fonction r\u00e9cursive permettant de cr\u00e9er un chemin al\u00e9atoirement dans le labyrinthe case par case pour les ennemis, \u00e0 chaque nouvel appel la probabilit\u00e9 de rallonger le chemin diminue : || func alterPath(pos : Vector2, proba : float) Renvoie toutes les combinaisons possibles entre plusieurs listes d\u2019un tableau de listes : || func combinaisons(a) G\u00e8re des instances de : Player , Wall , Bonus , BonusRange , BonusNombre , BonusPousser , BonusLumiere , BonusGodMode , BonusVitesse , HUD","title":"G\u00e9n\u00e9ration du labyrinthe"},{"location":"Maze/TileMap/","text":"TileMap.gd Ce script permet de g\u00e9rer le pathfinding des ennemis. Extends: [TileMap] Variables Objet Godot permettant de cr\u00e9er et de g\u00e9rer des chemins gr\u00e2ce un algorithme A : || var astar * Cases \u00e9tants utilisables (= cases avec du sol et non des murs incassables) : || var used_cells Chemin retourn\u00e9 par l\u2019algorithme A : || var path * Fonctions Sc\u00e8nes Fonction lanc\u00e9e \u00e0 l\u2019instanciation, sert \u00e0 lancer la pr\u00e9paration : || func ready() PathFinding A* Fonction de pr\u00e9paration, sert \u00e0 initialiser les variables d\u00e9clar\u00e9es plus t\u00f4t et \u00e0 ajouter les points empruntables au gestionnaire A et \u00e0 les relier entre eux: || func setup() * Ajoute les points list\u00e9s dans used_cells u gestionnaire A : || func add_points() * Relie les points du gestionnaire A entre eux pour lui dire qu\u2019il est possible de passer d\u2019une case \u00e0 une autre si elles sont directement adjacentes, utilise un syst\u00e8me d\u2019identifiant unique \u00e0 chaque case en fonction de ses cooronn\u00e9es: || func connect_points() * Renvoie le chemin le plus court empruntant les cases entr\u00e9es dans le gestionnaire A* partant de start pour aller \u00e0 end: || func get_path() Autres fonctions Permet de rendre des cases non empruntables depuis un tableau de cases utiles pour tenter d\u2019avoir un chemin qui ne repasse pas par des cases d\u00e9ja emprunt\u00e9es: || func removePoints() Renvoie l\u2019identifiant d\u2019un point en fonction de ses coordonn\u00e9es: || func id(point)","title":"TileMap"},{"location":"Maze/TileMap/#tilemapgd","text":"Ce script permet de g\u00e9rer le pathfinding des ennemis. Extends: [TileMap]","title":"TileMap.gd"},{"location":"Maze/TileMap/#variables","text":"Objet Godot permettant de cr\u00e9er et de g\u00e9rer des chemins gr\u00e2ce un algorithme A : || var astar * Cases \u00e9tants utilisables (= cases avec du sol et non des murs incassables) : || var used_cells Chemin retourn\u00e9 par l\u2019algorithme A : || var path *","title":"Variables"},{"location":"Maze/TileMap/#fonctions","text":"","title":"Fonctions"},{"location":"Maze/TileMap/#scenes","text":"Fonction lanc\u00e9e \u00e0 l\u2019instanciation, sert \u00e0 lancer la pr\u00e9paration : || func ready()","title":"Sc\u00e8nes"},{"location":"Maze/TileMap/#pathfinding-a","text":"Fonction de pr\u00e9paration, sert \u00e0 initialiser les variables d\u00e9clar\u00e9es plus t\u00f4t et \u00e0 ajouter les points empruntables au gestionnaire A et \u00e0 les relier entre eux: || func setup() * Ajoute les points list\u00e9s dans used_cells u gestionnaire A : || func add_points() * Relie les points du gestionnaire A entre eux pour lui dire qu\u2019il est possible de passer d\u2019une case \u00e0 une autre si elles sont directement adjacentes, utilise un syst\u00e8me d\u2019identifiant unique \u00e0 chaque case en fonction de ses cooronn\u00e9es: || func connect_points() * Renvoie le chemin le plus court empruntant les cases entr\u00e9es dans le gestionnaire A* partant de start pour aller \u00e0 end: || func get_path()","title":"PathFinding A*"},{"location":"Maze/TileMap/#autres-fonctions","text":"Permet de rendre des cases non empruntables depuis un tableau de cases utiles pour tenter d\u2019avoir un chemin qui ne repasse pas par des cases d\u00e9ja emprunt\u00e9es: || func removePoints() Renvoie l\u2019identifiant d\u2019un point en fonction de ses coordonn\u00e9es: || func id(point)","title":"Autres fonctions"},{"location":"Maze/Wall/","text":"Wall.gd Ce script permet de g\u00e9rer la destruction des murs cassables par les bombes du joueur. Extends: [KinematicBody2D] Fonctions Fonction appel\u00e9e lorsque le mur est dans la zone d\u2019explosion d\u2019une bombe lors de son explosion : || func bombed()","title":"Wall"},{"location":"Maze/Wall/#wallgd","text":"Ce script permet de g\u00e9rer la destruction des murs cassables par les bombes du joueur. Extends: [KinematicBody2D]","title":"Wall.gd"},{"location":"Maze/Wall/#fonctions","text":"Fonction appel\u00e9e lorsque le mur est dans la zone d\u2019explosion d\u2019une bombe lors de son explosion : || func bombed()","title":"Fonctions"}]}